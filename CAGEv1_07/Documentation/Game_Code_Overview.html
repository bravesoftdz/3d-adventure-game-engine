<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/TR/MathML2/dtd/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">Game Code Overview</title><meta name="DCTERMS.title" content="Game Code Overview" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.modified" content="2013-10-20T23:06:55" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><base href="."/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1_borderStart { border-left-style:none; border-right-style:none; border-top-style:none; font-size:6pt; margin-top:0in; padding:0in; font-family:Liberation Serif; writing-mode:page; font-weight:normal; padding-bottom:0.1965in;  border-bottom-style:none; }
	.P1 { border-left-style:none; border-right-style:none; font-size:6pt; padding:0in; font-family:Liberation Serif; writing-mode:page; font-weight:normal; padding-bottom:0.1965in; padding-top:0in;  border-top-style:none; border-bottom-style:none; }
	.P1_borderEnd { border-bottom-width:0.0399cm; border-bottom-style:double; border-bottom-color:#808080; border-left-style:none; border-right-style:none; font-size:6pt; margin-bottom:0.1965in; padding:0in; font-family:Liberation Serif; writing-mode:page; font-weight:normal; padding-top:0in;  border-top-style:none;}
	.P2 { font-size:12pt; font-weight:normal; margin-bottom:0.1965in; margin-top:0.1665in; font-family:Liberation Serif; writing-mode:page; }
	.P3 { font-size:10pt; font-weight:bold; margin-bottom:0in; margin-top:0.1665in; font-family:Liberation Serif; writing-mode:page; }
	.T1 { color:#007f00; font-family:!Bitstream Vera Sans Mono; font-size:10pt; }
	.T10 { color:#007f7f; }
	.T3 { font-weight:bold; }
	.T4 { color:#00007f; }
	.T6 { color:#808080; }
	.T7 { color:#808080; font-weight:bold; }
	.T8 { color:#000000; }
	<!-- ODF styles with no properties representable as CSS -->
	{ }
	</style></head><body dir="ltr" style="max-width:8.5in;margin-top:0.3937in; margin-bottom:0.3937in; margin-left:0.7874in; margin-right:0.3937in; background-color:#ffffff; "><h5 class="P2"><a id="a__This_is_an_overview_of_the_code_that_is_in_scene1_c_"><span/></a>This is an overview of the code that is in scene1.c.</h5><HR><h5 class="P2"><a id="a_____GAME_LOGIC___if__initializeDrawScene1_{   The_code_within_this_if_statement_is_only_executed_once_   and_will_not_executed_again_even_if_scene1_has_restarted_   initializeDrawScene1_=_0_}if__resetDrawScene_{   The_code_within_this_if_statement_is   executed_every_time_scene1_is_restarted_   resetDrawScene_=_0_}___return_global_and_transformation_data_back_to_its_original_state___this_will_keep_rounding_errors_from_deforming_the_meshesThis_is_where_meshes_are_put_back_to_there_original_states_as_if_the_have_not_moved_at_all__This_means_there_positions_have_to_be_recalculated_for_each_frame____After_changing_the_course's_orientation_its_x's_and_y's____will_no_longer_be_aligned_horizontally_and_vertically____So_position_objects_before_this_point_because_it_might_be_harder___to_position_them_once_the_course's_orientation_has_changed_This_is_were_the_course_moves_to_the_position_where_it_left_off__This_means_the_character_is_place_in_the_right_position_on_the_course____Temporarily_rotate_the_course_so_that_its___x's_and_y's_are_aligned_horizontally_and_vertically____Keep_the_rotation_data_to_return_the_course_back___to_its_normal_rotation_The_course's_orientation_has_changed_so_that_its_x's_and_y's_are_aligned_horizontally_and_vertically_just_like_before_except_the_character_keeps_its_position_relative_to_the_course_this_time____If_the_character_falls_or_jumps_this_changes_the_z___position_of_the_course_and_if_you_have_objects_placed_on___the_course_this_is_the_place_to_change_the_z_positions___of_those_objects_to_keep_them_with_the_course_After_this_point_the_characters_z_position_is_correctly_calculated_after_falling_or_jumping_____return_the_course_back_to_its_normal_rotationThe_course's_orientation_is_put_back_to_where_it_needs_to_be_for_rendering____DRAW______fill_z-index_bufferfor__y_=_0__y___rI_yWin__y___for__x_=_0__x___rI_xWin__x___rI_zIndex_x__y__=_rI_camEndZ_Any_thing_less_than_rI_camEndZ_will_not_be_drawn____color_backgroundfor__y_=_0__y___rI_yWin__y___for__x_=_0__x___rI_xWin__x___rI_scrnBuff_x__y__=_bgColor_bgColor_is_painted_to_the_screen_addRotLocSz_mesh_TRANS__mesh_POINT__mesh_POINTDATSZ_            mesh_STATICPOINT__mesh_MESHCNT__This_function_applies_the_transformation_data_to_the_vertices_addScreenRotLocSz_xScreenRot__yScreenRot__zScreenRot_                  xScreenSize__yScreenSize__zScreenSize_                  xScreenLoc__yScreenLoc__zScreenLoc_                  mesh_POINT__mesh_POINTDATSZ__mesh_MESHCNT__This_function_changes_the_orientation_of_the_vertices_again_drawMesh_mesh_POINT__mesh_LINE__mesh_COLOR_         mesh_LINEDATSZ__mesh_MESHCNT__bgColor__antialiasing__rI__This_function_draws_a_mesh_"><span/></a><br/><span class="T1">// GAME LOGIC //</span><br/><br/><span class="T4">if</span><span class="T6"> </span><span class="T8">(</span>initializeDrawScene1<span class="T8">)</span><br/><span class="T8">{</span><br/><span class="T7">   </span><span class="T3">The code within this if statement is only executed once <br/>   and will not executed again even if scene1 has restarted.</span><br/><br/><span class="T6">   </span>initializeDrawScene1<span class="T6"> </span><span class="T8">=</span><span class="T6"> </span><span class="T10">0</span><span class="T8">;</span><br/><span class="T8">}</span><br/><br/><span class="T4">if</span><span class="T6"> </span><span class="T8">(</span>resetDrawScene<span class="T8">)</span><br/><span class="T8">{</span><br/><span class="T7">   </span><span class="T3">The code within this if statement is<br/>   executed every time scene1 is restarted.</span><br/><br/><span class="T6">   </span>resetDrawScene<span class="T6"> </span><span class="T8">=</span><span class="T6"> </span><span class="T10">0</span><span class="T8">;</span><br/><span class="T8">}</span><br/><br/><br/><span class="T1">// return global and transformation data back to its original state</span><br/><span class="T1">// this will keep rounding errors from deforming the meshes</span><br/><br/><span class="T3">This is where meshes are put back to there original states as if they have not moved at all. This means their orientations have to be recalculated for each frame.</span><br/><br/><br/><span class="T1">// After changing the course's orientation its x's and y's </span><br/><span class="T1">// will no longer be aligned horizontally and vertically.</span><br/><span class="T1">// So position objects before this point because it might be harder</span><br/><span class="T1">// to position them once the course's orientation has changed.</span><br/><br/><span class="T3">This is were the course moves to the position where it left off. This means the character is placed in the right position on the course.</span><br/><br/><br/><span class="T1">// Temporarily rotate the course so that its</span><br/><span class="T1">// x's and y's are aligned horizontally and vertically.</span><br/><span class="T1">// Keep the rotation data to return the course back</span><br/><span class="T1">// to its normal rotation.</span><br/><br/><span class="T3">The course's orientation has changed so that its x's and y's are aligned horizontally and vertically just like before except the character keeps its position relative to the course this time.</span><br/><br/><br/><span class="T1">// If the character falls or jumps this changes the z</span><br/><span class="T1">// position of the course and if you have objects placed on</span><br/><span class="T1">// the course this is the place to change the z positions</span><br/><span class="T1">// of those objects to keep them with the course.</span><br/><br/><span class="T3">After this point the characters z position is correctly calculated after falling or jumping. </span><br/><br/><br/><span class="T1">// return the course back to its normal rotation</span><br/><br/><span class="T3">The course's orientation is put back to where it needs to be for rendering.</span><br/><br/><br/><span class="T1">// DRAW //</span><br/><br/><span class="T1">// fill z-index buffer</span><br/><span class="T4">for</span><span class="T6"> </span><span class="T8">(</span>y<span class="T6"> </span><span class="T8">=</span><span class="T6"> </span><span class="T10">0</span><span class="T8">;</span><span class="T6"> </span>y<span class="T6"> </span><span class="T8">&lt;</span><span class="T6"> </span>rI<span class="T8">.</span>yWin<span class="T8">;</span><span class="T6"> </span>y<span class="T8">++)</span><br/><span class="T4">for</span><span class="T6"> </span><span class="T8">(</span>x<span class="T6"> </span><span class="T8">=</span><span class="T6"> </span><span class="T10">0</span><span class="T8">;</span><span class="T6"> </span>x<span class="T6"> </span><span class="T8">&lt;</span><span class="T6"> </span>rI<span class="T8">.</span>xWin<span class="T8">;</span><span class="T6"> </span>x<span class="T8">++)</span><br/>rI<span class="T8">.</span>zIndex<span class="T8">[</span>x<span class="T8">][</span>y<span class="T8">]</span><span class="T6"> </span><span class="T8">=</span><span class="T6"> </span>rI<span class="T8">.</span>camEndZ<span class="T8">;</span><br/><br/><span class="T3">Anything less than rI.camEndZ will not be drawn.</span><br/><br/><br/><span class="T1">// color background</span><br/><span class="T4">for</span><span class="T6"> </span><span class="T8">(</span>y<span class="T6"> </span><span class="T8">=</span><span class="T6"> </span><span class="T10">0</span><span class="T8">;</span><span class="T6"> </span>y<span class="T6"> </span><span class="T8">&lt;</span><span class="T6"> </span>rI<span class="T8">.</span>yWin<span class="T8">;</span><span class="T6"> </span>y<span class="T8">++)</span><br/><span class="T4">for</span><span class="T6"> </span><span class="T8">(</span>x<span class="T6"> </span><span class="T8">=</span><span class="T6"> </span><span class="T10">0</span><span class="T8">;</span><span class="T6"> </span>x<span class="T6"> </span><span class="T8">&lt;</span><span class="T6"> </span>rI<span class="T8">.</span>xWin<span class="T8">;</span><span class="T6"> </span>x<span class="T8">++)</span><br/>rI<span class="T8">.</span>scrnBuff<span class="T8">[</span>x<span class="T8">][</span>y<span class="T8">]</span><span class="T6"> </span><span class="T8">=</span><span class="T6"> </span>bgColor<span class="T8">;</span><br/><br/><span class="T3">bgColor is painted to the screen.</span><br/><br/><br/>addRotLocSz<span class="T8">(</span>mesh_TRANS<span class="T8">,</span><span class="T6"> </span>mesh_POINT<span class="T8">,</span><span class="T6"> </span>mesh_POINTDATSZ<span class="T8">,</span><br/><span class="T6">            </span>mesh_STATICPOINT<span class="T8">,</span><span class="T6"> </span>mesh_MESHCNT<span class="T8">);</span><br/><br/><span class="T3">This function applies the transformation data to the vertices.</span><br/><br/><br/>addScreenRotLocSz<span class="T8">(</span>xScreenRot<span class="T8">,</span><span class="T6"> </span>yScreenRot<span class="T8">,</span><span class="T6"> </span>zScreenRot<span class="T8">,</span><br/><span class="T6">                  </span>xScreenSize<span class="T8">,</span><span class="T6"> </span>yScreenSize<span class="T8">,</span><span class="T6"> </span>zScreenSize<span class="T8">,</span><br/><span class="T6">                  </span>xScreenLoc<span class="T8">,</span><span class="T6"> </span>yScreenLoc<span class="T8">,</span><span class="T6"> </span>zScreenLoc<span class="T8">,</span><br/><span class="T6">                  </span>mesh_POINT<span class="T8">,</span><span class="T6"> </span>mesh_POINTDATSZ<span class="T8">,</span><span class="T6"> </span>mesh_MESHCNT<span class="T8">);</span><br/><br/><span class="T3">This function changes the orientation of the vertices again.</span><br/><br/><br/>drawMesh<span class="T8">(</span>mesh_POINT<span class="T8">,</span><span class="T6"> </span>mesh_LINE<span class="T8">,</span><span class="T6"> </span>mesh_COLOR<span class="T8">,</span><br/><span class="T6">         </span>mesh_LINEDATSZ<span class="T8">,</span><span class="T6"> </span>mesh_MESHCNT<span class="T8">,</span><span class="T6"> </span>bgColor<span class="T8">,</span><span class="T6"> </span>antialiasing<span class="T8">,</span><span class="T6"> </span>rI<span class="T8">);</span><br/><br/><span class="T3">This function draws a mesh.</span><p class="P1"> </p>
<HR>
<BR>
</h5>
</body></html>
